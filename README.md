# Crud_Lite - A sample lightweight CRUD app, written in C11 with Win32 and Sqlite3

A simple database program for Windows. Supports various database operations via SQLite3, and can be used with ease thanks to it's Win32 gui.     

## Operation
![Imgur](https://i.imgur.com/mb6l96d.png)

The program opens with the search window, which allows the user to search for record via either their first, or last name. Pressing search with the serch field empty will simply display all records contained within the database.

To select a record, double-click on it in the ListView control. 

![Imgur](https://i.imgur.com/wexBxvs.png)

This will bring up a display of the current record, and all it's stored information (currently in a rather spartan manner).

![Imgur](https://i.imgur.com/zsEqn8r.png)

From here the record can be edited, or deleted. 

![Imgur](https://i.imgur.com/KN9wx3k.png)

The user will be notified if any important information is omitted.


## Building

Win32 supports the concept of a _resource_ (.rc) file, which allows you to add external assets like strings and bitmaps into the .exe file at compile time. While this will result in a bigger binary, it removes the need to load assets at runtime, and keep them knocking around on the heap. If your compiler of choice is supported by Visual Studio, the process is very easy and more or less automated through the gui. 
 
The choice of C compilers for windows that support C99/C11 is sadly rather limited. I use MinGW-w64, which happily, comes bundled with a little tool called Windres, which will compile the contents of the resource file to an object file, that you can link to. Thus, the build command is split into 3 stages. 
```
gcc -ggdb -Wall -std=c11 -O3 -Iinclude src/cl_win32.c -c -o build/crud_lite.o
windres -i src/cl_resource.rc -o build/resource.o
gcc -Llib build/crud_lite.o build/resource.o -o crud_lite.exe -luser32 -lgdi32 -lcomctl32 -lsqlite3
```
Currently, the only assets that the .rc file contains are two bitmaps, and two strings. However, there is another, and fairly  important item contained within, the name and path of the _manifest file_. This is a simple XML document, that specifies the version of Common Controls (the bread & butter of a Win32 program) the program will use. If this is included, everything looks fine, but if it isn't, all of the controls take on a distinctly retro look that will look out of place on a Windows Vista/7/8/10 desktop.

## Implementation

This function is the entry point for program, as well as the main loop. A Win32 program has own entry point, and the standard 'main' will not work here. So we're using [WinMain](https://docs.microsoft.com/en-us/windows/desktop/LearnWin32/winmain--the-application-entry-point). Aside from the name change, it also has it's own parameters, the one of most import for us is `hInstance', generated by Windows, which contains a pointer the .exe's position in memory. We don't need to worry too much about the details of this, however, it will required as an argument for many of the windows functions we're going to use. 

The first section of code initializers Common Controls. These are a series of pre-made Windows controls, that allow the developer to use some more fancy gui controls, rather than rely on the basic controls that are provided with user32.dll. While they contain nothing particularly exiting by modern standards (think tabs, tool bars, etc), without them a Win32 application would look incredibly basic and lack modern functionality. We just have to tell Windows that the program will be using them ahead of time.   

```c
int CALLBACK WinMain(HINSTANCE hInstance,
		     HINSTANCE hPrevInstance,
		     LPSTR lpCmdLine,
		     int nCmdShow)
{
	INITCOMMONCONTROLSEX commCtrl;
	commCtrl.dwSize = sizeof(INITCOMMONCONTROLSEX);
	commCtrl.dwICC = ICC_TAB_CLASSES|ICC_STANDARD_CLASSES|ICC_LISTVIEW_CLASSES;
	InitCommonControlsEx(&commCtrl);
	
	//	The main window class. cbClsExtra sets space for extra data, 
	//	which we will use to store a pointer to the program's state,
	// 	so we can access it inside WindowProcs without using globals.	
	
	WNDCLASSEX wc = {};
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.cbClsExtra = sizeof(ULONG_PTR);
	wc.style = CS_VREDRAW|CS_HREDRAW;
	wc.lpfnWndProc = win32_Proc;
	wc.hInstance = hInstance;
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszClassName = "WINCLASS_MAINWINDOW";		
	if(!RegisterClassEx(&wc)) {return(1);}	
	
	HWND mainWindow = CreateWindowEx(WS_EX_APPWINDOW, wc.lpszClassName, "Crud Lite", 
		WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN|WS_VISIBLE, 
		CW_USEDEFAULT, CW_USEDEFAULT, 896, 512, NULL, 0, hInstance, 0);
	if(!mainWindow) {return(1);}
	
	MSG msg;	
	while(GetMessage(&msg, NULL, 0, 0) != 0) {				
	
		TranslateMessage(&msg);
		DispatchMessage(&msg);					
	}	
	
	return(0);
}
```

The next thing to do is populate a [WNDCLASSEX](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassexa) structure. This will populate a structure that defines aspects of the programs main window. Not everything in the struct needs a value, Windows will initialize any unpopulated members to NULL. This is sent to the [RegisterClassEx](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassexa), and if this function fails (usually a result of the wrong data being entered, or an essential field being omitted), the program cannot start. A registered class is needed to pass to [CreateWindowEx](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createwindowexa), which will actually make the window. 

There are two members of the `WNDCLASSEX` structure that merit further explanation, first is `lpfnWndProc`, which requires a function pointer to the [WindowProc](https://msdn.microsoft.com/en-us/library/windows/desktop/ms633573(v=vs.85).aspx) function. In many ways the core of a Win32 program, which will be explained soon. The other is `cbClsExtra`, which expands the size of the `WNDCLASSEX` by size given. This allows us to store any extra data we need in the class. For our purposes, a simple pointer will suffice (ULONG_PTR is a [built-in windows](https://docs.microsoft.com/en-us/windows/desktop/winprog/windows-data-types) type, meaning 64bit pointer).

### The WindowProc

