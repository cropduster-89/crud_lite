# Crud_Lite - A sample lightweight CRUD app, written in C11 with Win32 and Sqlite3

## 1.0 [Intro ](#1-0)<br/>
### 1.1 [Functionality ](#1-1)<br/>
### 1.2 [Building ](#1-2)<br/>


<a name="1-0"></a>
# 1.0 Intro

A simple database program for Windows. Supports various database operations via SQLite3, and can be used with ease thanks to it's Win32 gui.     

<a name="1-1"></a>
## 1.1 Functionality
![Imgur](https://i.imgur.com/mb6l96d.png)

The program opens with the search window, which allows the user to search for record via either their first, or last name. Pressing search with the serch field empty will simply display all records contained within the database.

To select a record, double-click on it in the ListView control. 

![Imgur](https://i.imgur.com/wexBxvs.png)

This will bring up a display of the current record, and all it's stored information (currently in a rather spartan manner).

![Imgur](https://i.imgur.com/zsEqn8r.png)

From here the record can be edited, or deleted. 

![Imgur](https://i.imgur.com/KN9wx3k.png)

The user will be notified if any important information is omitted.


<a name="1-2"></a>
## 1.2 Building

Win32 supports the concept of a _resource_ (.rc) file, which allows you to add external assets like strings and bitmaps into the .exe file at compile time. While this will result in a bigger binary, it removes the need to load assets at runtime, and keep them knocking around on the heap. If your compiler of choice is supported by Visual Studio, the process is very easy and more or less automated through the gui. 
 
The choice of C compilers for windows that support C99/C11 is sadly rather limited. I use MinGW-w64, which happily, comes bundled with a little tool called Windres, which will compile the contents of the resource file to an object file, that you can link to. Thus, the build command is split into 3 stages. 
```
gcc -ggdb -Wall -std=c11 -O3 -Iinclude src/cl_win32.c -c -o build/crud_lite.o
windres -i src/cl_resource.rc -o build/resource.o
gcc -Llib build/crud_lite.o build/resource.o -o crud_lite.exe -luser32 -lgdi32 -lcomctl32 -lsqlite3
```
Currently, the only assets that the .rc file contains are two bitmaps, and two strings. However, there is another, and fairly  important item contained within, the name and path of the _manifest file_. This is a simple XML document, that specifies the version of Common Controls (the bread & butter of a Win32 program) the program will use. If this is included, everything looks fine, but if it isn't, all of the controls take on a distinctly retro look that will look out of place on a Windows Vista/7/8/10 desktop.

## Implementation

This function is the entry point for program, as well as the main loop. A Win32 program has own entry point, and the standard 'main' will not work here. So we're using [WinMain](https://docs.microsoft.com/en-us/windows/desktop/LearnWin32/winmain--the-application-entry-point). Aside from the name change, it also has it's own parameters, the one of most import for us is `hInstance`, generated by Windows, which contains a pointer the .exe's position in memory. We don't need to worry too much about the details of this, however, it will be required as an argument for many of the windows functions we're going to use. 

The first section of code initializers Common Controls. These are a series of pre-made Windows controls, that allow the developer to use some more fancy gui controls, rather than rely on the basic controls that are provided with user32.dll. While they contain nothing particularly exiting by modern standards (think tabs, tool bars, etc), without them a Win32 application would look incredibly basic and lack modern functionality. We just have to tell Windows that the program will be using them ahead of time.   

```c
int CALLBACK WinMain(HINSTANCE hInstance,
		     HINSTANCE hPrevInstance,
		     LPSTR lpCmdLine,
		     int nCmdShow)
{
	INITCOMMONCONTROLSEX commCtrl;
	commCtrl.dwSize = sizeof(INITCOMMONCONTROLSEX);
	commCtrl.dwICC = ICC_TAB_CLASSES|ICC_STANDARD_CLASSES|ICC_LISTVIEW_CLASSES;
	InitCommonControlsEx(&commCtrl);
	
	//	The main window class. cbClsExtra sets space for extra data, 
	//	which we will use to store a pointer to the program's state,
	// 	so we can access it inside WindowProcs without using globals.	
	
	WNDCLASSEX wc = {};
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.cbClsExtra = sizeof(ULONG_PTR);
	wc.style = CS_VREDRAW|CS_HREDRAW;
	wc.lpfnWndProc = win32_Proc;
	wc.hInstance = hInstance;
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszClassName = "WINCLASS_MAINWINDOW";		
	if(!RegisterClassEx(&wc)) {return(1);}	
	
	HWND mainWindow = CreateWindowEx(WS_EX_APPWINDOW, wc.lpszClassName, "Crud Lite", 
		WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN|WS_VISIBLE, 
		CW_USEDEFAULT, CW_USEDEFAULT, 896, 512, NULL, 0, hInstance, 0);
	if(!mainWindow) {return(1);}
	
	MSG msg;	
	while(GetMessage(&msg, NULL, 0, 0) != 0) {				
	
		TranslateMessage(&msg);
		DispatchMessage(&msg);					
	}	
	
	return(0);
}
```

The next thing to do is populate a [WNDCLASSEX](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagwndclassexa) structure. This will populate a structure that defines aspects of the programs main window. Not everything in the struct needs a value, Windows will initialize any unpopulated members to NULL. This is sent to the [RegisterClassEx](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassexa), and if this function fails (usually a result of the wrong data being entered, or an essential field being omitted), the program cannot start. A registered class is needed to pass to [CreateWindowEx](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createwindowexa), which will actually make the window. 

There are two members of the `WNDCLASSEX` structure that merit further explanation, first is `lpfnWndProc`, which requires a function pointer to the [WindowProc](https://msdn.microsoft.com/en-us/library/windows/desktop/ms633573(v=vs.85).aspx) function. In many ways the core of a Win32 program, which will be explained soon. The other is `cbClsExtra`, which expands the size of the `WNDCLASSEX` by size given. This allows us to store any extra data we need in the class. For our purposes, a simple pointer will suffice (ULONG_PTR is a [built-in windows](https://docs.microsoft.com/en-us/windows/desktop/winprog/windows-data-types) type, meaning 64bit pointer).

Beneath this is the main message loop. This will check for any messages generated by either the user, or Windows itself, and send them to the WindowProc where they can be processes. The loop is exited when [GetMessage](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getmessage) returns 0, which will be when, and only when it receives a WM_QUIT message (it's value is 0, you see?). Something to note, is that `GetMessage` waits until it actually has a message to process before continuing to the next iteration of the loop. This behaviour is fine for an event driven gui application like this, but will totally break a real-time program, like a game. In that case, you will want to use `PeekMessage` instead.

### The WindowProc

At the core of a Win32 application, lies the Window Procedure. Most GUI frameworks and libraries have some sort of event driven mechanism that activates when the user presses a button or resizes a window, where the developer can write the desired response. The twist here in Win32, is that the user shares this message processing system with the OS itself. If you open task manager and click End Task for a windows program, Windows itself will send a WM_CLOSE message to the programs WindowProc, and will expect it to respond accordingly. This raises some problems. How do you, the developer, know what Windows wants to happen? Well there's a simple solution. The default case for the WindProcs witch statement contains the function, [DefWindowProc](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-defwindowproca), which allows to handle the message itself. Over the course of your programs runtime and huge amount of messages will be handled by `DefWindowProc`, most of which you don't need to worry about. This does mean however, you should carefully gage what messages you handle yourself, and make sure they do not conflict with the default expected behavior of a Windows program. A program that doesn't default to `DefWindowProc` will be non-functional, probably non-visible, and has only seconds before it crashes completely.            

```c
LRESULT CALLBACK win32_Proc(HWND window,
			    UINT msg,
			    WPARAM wParam,
			    LPARAM lParam)
{
	LRESULT result = 0;
	
	switch(msg) {	
	case WM_DESTROY: {
		
		//	code goes here!
		
		break;
		
	} case WM_CREATE: {
		
		//	code goes here!
		
		break;	
		
	} case WM_COMMAND: {
		
		//	code goes here!
		
		break;
		
	} default: {
		result = DefWindowProcA(window, msg, wParam, lParam);
	}	
	}
	
	return(result);
}
```
This programs main Window only processes 3 messages.

#### For Starting Up

The `WM_CREATE` message is sent when a window is created, (before `CreateWindowEx` returns in fact). And here, it's use as the place to create our various controls, and child windows. While these tasks are often performed in `WM_CREATE`, it is in no way essential that they are, and you can do your startup however you want after the inital window has been created.  

What we will do here, is make some new window classes, for the sub-windows, and their controls, with their own WindowProcs. 

While it is possible to perfrom all processing for a single program in a single WindowProc, the code with quickly grow very unwieldy, so it makes sense to subclass them.  

##### Limiting use of Global Variables

As a result of us having to share this function with windows, we can't set any of the parameters ourselves. We only have the four we're given; a window handle, the code for the message, and two others, a WPARAM, and a LPARAM which contain data that changes depending on the event. This limitiation in the programs core event processing functions causes many Win32 programs to use a plethora of global variables, but that's totally avoidable.

Remember the `cbClsExtra` field of the window class? Well here's it's time to shine. The main window class will availible from any of it's children, from any WindowProc, and we've given it some extra data, which it's now time to intialize.

```c
struct gui_state *gs = calloc(1, sizeof(struct gui_state));		
SetClassLongPtr(window, 0, (ULONG_PTR)gs);		
gs->mainWindow = window;
gs->hInstance = (HINSTANCE)GetModuleHandle(NULL);
```

gui_state is a custom struct that contains handles to our various controls and windows so we can grab data from them where ever it's required. The [SetClassLongPtr](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setclasslongptra) function sets data field in the widowclass. The second parameter is an offset, where '0' is the location of the `cbClsExtra`, which we'll set to our struct, newly allocated on the heap.  

As only the main window class was allocated extra space, some extra work is needed to ensure the state can be grabbed from any subsequent child windows that need the data.

```c
extern struct gui_state *win32_GetState(HWND window)
{
	HWND parent = window, temp = window;	
	
	while(1) {
		temp = GetParent(temp);
		if(temp) {
			parent = temp;
		} else {break;}
	}	
	struct gui_state *gs = (struct gui_state *)GetClassLongPtr(parent, 0);
	assert(gs);
	
	return(gs);
}
```
This function does just that. The [GetParent](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getparent) function returns a handle to the parent window of the window given as a argument. If it has no parent, the funtion returns NULL, and we can safely assume it's safe to get the state using [GetClassLongPtr](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getclasslongptra).

#### For Shutting Down

There are 3 messages invloved in shutdown, `WM_CLOSE` which Windows sends when the user requests the window be closed, most usually with the X button. This is the request to close, and if you want to handle it, is a prime to prompt the user to save, and confirm or abort the shutdown. Windows' default behaviour here is to simply call the `WM_DESTORY` message, and the programmer should do this too after any desired prompts have been given.    

`WM_DESTROY` is the message you want to handle when managing your programs shutdown, where you free any resources,  or try and bring an ongoing task to a safe and dignified end in an unexpected shutdown. It is created when the window has been destroyed. It is the only one we're going to handle currently.

Finally, `WM_QUIT` is a simple message with the value 0. It isn't intended to processed by the WindowProc, so we won't. It's only real goal is to break out of the message processing loop. 

#### Handling 
